//! The components to construct an asynchronous HTTP service from the `Endpoint`.

use futures::{self, Async, Future, Poll};
use http::header::{self, HeaderValue};
use http::{Request, Response};
use hyper::body::Body;
use hyper::service::{NewService, Service};
use slog::Logger;
use std::boxed::PinBox;
use std::sync::Arc;
use std::time;
use std::{fmt, io};

use futures_util::compat::{Compat, TokioDefaultExecutor};
use futures_util::try_future::{IntoFuture, TryFutureExt};

use finchers_core::either::Either;
use finchers_core::endpoint::{Context, Endpoint};
use finchers_core::error::{Error, HttpError, NoRoute};
use finchers_core::input::{with_set_cx, Input, RequestBody};
use finchers_core::output::payloads::Once;
use finchers_core::output::Responder;

/// A factory of HTTP service which wraps an `Endpoint`.
#[derive(Debug)]
pub struct App<E: Endpoint> {
    data: Arc<AppData<E>>,
}

struct AppData<E: Endpoint> {
    endpoint: E,
    logger: Logger,
    error_handler: ErrorHandler,
}

impl<E: Endpoint + fmt::Debug> fmt::Debug for AppData<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("AppData")
            .field("endpoint", &self.endpoint)
            .finish()
    }
}

impl<E: Endpoint> App<E> {
    /// Create a new `App` from the provided components.
    pub fn new(endpoint: E, logger: Logger) -> App<E> {
        App {
            data: Arc::new(AppData {
                endpoint,
                logger,
                error_handler: default_error_handler,
            }),
        }
    }
}

impl<E: Endpoint> NewService for App<E> {
    type ReqBody = Body;
    type ResBody = Either<Once<String>, <E::Ok as Responder>::Body>;
    type Error = io::Error;
    type Service = AppService<E>;
    type InitError = io::Error;
    type Future = futures::future::FutureResult<Self::Service, Self::InitError>;

    fn new_service(&self) -> Self::Future {
        futures::future::ok(AppService {
            data: self.data.clone(),
        })
    }
}

/// An asynchronous HTTP service which holds an `Endpoint`.
///
/// The value of this type is generated by `NewEndpointService`.
#[derive(Debug)]
pub struct AppService<E: Endpoint> {
    data: Arc<AppData<E>>,
}

impl<E: Endpoint> Service for AppService<E> {
    type ReqBody = Body;
    type ResBody = Either<Once<String>, <E::Ok as Responder>::Body>;
    type Error = io::Error;
    type Future = AppServiceFuture<Compat<PinBox<IntoFuture<E::Future>>, TokioDefaultExecutor>>;

    fn call(&mut self, request: Request<Self::ReqBody>) -> Self::Future {
        let request = request.map(RequestBody::from_hyp);
        let logger = self.data.logger.new(o!{
            "method" => request.method().to_string(),
            "path" => request.uri().path().to_owned(),
        });
        let input = Input::new(request);
        let in_flight = self.data.endpoint.apply(&mut Context::new(&input));
        let in_flight =
            in_flight.map(|future| PinBox::new(future.into_future()).compat(TokioDefaultExecutor));

        AppServiceFuture {
            in_flight,
            input,
            logger,
            start: time::Instant::now(),
            error_handler: self.data.error_handler,
        }
    }
}

#[allow(missing_docs)]
#[allow(missing_debug_implementations)]
pub struct AppServiceFuture<T> {
    in_flight: Option<T>,
    input: Input,
    logger: Logger,
    start: time::Instant,
    error_handler: ErrorHandler,
}

impl<T> AppServiceFuture<T> {
    fn handle_error(&self, err: &HttpError) -> Response<Once<String>> {
        (self.error_handler)(err, &self.input).map(Once::new)
    }
}

impl<T> Future for AppServiceFuture<T>
where
    T: Future,
    T::Item: Responder,
    T::Error: Into<Error>,
{
    type Item = Response<Either<Once<String>, <T::Item as Responder>::Body>>;
    type Error = io::Error;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        let polled = {
            let logger = &self.logger;
            let in_flight = &mut self.in_flight;
            let input = &mut self.input;
            LOGGER.set(logger, || match in_flight {
                Some(ref mut f) => with_set_cx(input, || Some(f.poll())),
                None => None,
            })
        };

        let output = match polled {
            Some(Ok(Async::NotReady)) => return Ok(Async::NotReady),
            Some(Ok(Async::Ready(x))) => x
                .respond(&self.input)
                .map(|res| res.map(Either::Right))
                .map_err(Into::into),
            Some(Err(err)) => Err(err.into()),
            None => Err(NoRoute.into()),
        };

        let mut response =
            output.unwrap_or_else(|err| self.handle_error(err.as_http_error()).map(Either::Left));

        if !response.headers().contains_key(header::SERVER) {
            response.headers_mut().insert(
                header::SERVER,
                HeaderValue::from_static(concat!("finchers-runtime/", env!("CARGO_PKG_VERSION"))),
            );
        }

        let end = time::Instant::now();
        let duration = end - self.start;
        let duration_msec = duration.as_secs() * 10 + duration.subsec_nanos() as u64 / 1_000_000;
        info!(self.logger, "{} ({} ms)", response.status(), duration_msec);

        Ok(Async::Ready(response))
    }
}

// ==== Logger ====

scoped_thread_local!(static LOGGER: Logger);

/// Execute a closure with the reference to `Logger` associated with the current scope.
pub fn with_logger<F, R>(f: F) -> R
where
    F: FnOnce(&Logger) -> R,
{
    LOGGER.with(|logger| f(logger))
}

// ==== ErrorHandler ====

/// A type alias of the error handler used by `EndpointService`.
pub type ErrorHandler = fn(&HttpError, &Input) -> Response<String>;

fn default_error_handler(err: &HttpError, _: &Input) -> Response<String> {
    let mut response = Response::new(format!("{:#}", err));
    *response.status_mut() = err.status_code();
    response.headers_mut().insert(
        header::CONTENT_TYPE,
        HeaderValue::from_static("text/plain; charset=utf-8"),
    );
    err.headers(response.headers_mut());
    response
}
