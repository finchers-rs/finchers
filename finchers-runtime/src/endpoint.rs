//! The components to construct an asynchronous HTTP service from the `Endpoint`.

use bytes::Bytes;
use futures;
use futures::future::{self, FutureResult};
use futures::Async::*;
use http::header::{self, HeaderValue};
use http::{Request, Response};
use std::sync::Arc;
use std::{fmt, io};

use finchers_core::endpoint::{Context, EndpointBase};
use finchers_core::future::{Future, Poll};
use finchers_core::input::RequestBody;
use finchers_core::output::{Responder, ResponseBody};
use finchers_core::{Endpoint, Error, HttpError, Input};

use apply::{apply_request, ApplyRequest};
use service::{HttpService, NewHttpService, Payload};

// FIXME: move the implementation to finchers-core after replacing `Payload` with `hyper::Payload`.
impl Payload for ResponseBody {
    type Data = Bytes;
    type Error = io::Error;

    fn poll_data(&mut self) -> futures::Poll<Option<Self::Data>, Self::Error> {
        match self.poll_data() {
            Poll::Pending => Ok(NotReady),
            Poll::Ready(Ok(chunk)) => Ok(Ready(chunk)),
            Poll::Ready(Err(err)) => Err(err),
        }
    }
}

trait EndpointLiftExt {
    fn lift(&self) -> Lift<Self>;
}

impl<E> EndpointLiftExt for E
where
    E: Endpoint,
{
    fn lift(&self) -> Lift<Self> {
        Lift(self)
    }
}

struct Lift<'a, E: 'a + ?Sized>(&'a E);

impl<'a, E: 'a + ?Sized + Endpoint> EndpointBase for Lift<'a, E> {
    type Output = E::Output;
    type Future = E::Future;

    fn apply(&self, cx: &mut Context) -> Option<Self::Future> {
        self.0.apply(cx)
    }
}

/// A factory of HTTP service which wraps an `Endpoint`.
pub struct NewEndpointService<E> {
    endpoint: Arc<E>,
    error_handler: ErrorHandler,
}

impl<E: fmt::Debug> fmt::Debug for NewEndpointService<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("NewEndpointService")
            .field("endpoint", &self.endpoint)
            .finish()
    }
}

impl<E> NewEndpointService<E>
where
    E: Endpoint,
{
    /// Create a new `NewEndpointService` from an endpoint.
    pub fn new(endpoint: E) -> NewEndpointService<E> {
        NewEndpointService {
            endpoint: Arc::new(endpoint),
            error_handler: default_error_handler,
        }
    }

    /// Set the error handler used in this service.
    pub fn set_error_handler(&mut self, handler: ErrorHandler) {
        self.error_handler = handler;
    }
}

impl<E> NewHttpService for NewEndpointService<E>
where
    E: Endpoint,
{
    type RequestBody = RequestBody;
    type ResponseBody = ResponseBody;
    type Error = io::Error;
    type Service = EndpointService<E>;
    type InitError = io::Error;
    type Future = FutureResult<Self::Service, Self::InitError>;

    fn new_service(&self) -> Self::Future {
        future::ok(EndpointService {
            endpoint: self.endpoint.clone(),
            error_handler: self.error_handler,
            _priv: (),
        })
    }
}

/// An asynchronous HTTP service which holds an `Endpoint`.
///
/// The value of this type is generated by `NewEndpointService`.
pub struct EndpointService<E> {
    endpoint: Arc<E>,
    error_handler: ErrorHandler,
    _priv: (),
}

impl<E: fmt::Debug> fmt::Debug for EndpointService<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("EndpointService")
            .field("endpoint", &self.endpoint)
            .finish()
    }
}

impl<E> HttpService for EndpointService<E>
where
    E: Endpoint,
{
    type RequestBody = RequestBody;
    type ResponseBody = ResponseBody;
    type Error = io::Error;
    type Future = EndpointServiceFuture<E::Future>;

    fn call(&mut self, request: Request<Self::RequestBody>) -> Self::Future {
        let input = Input::new(request);
        let apply = apply_request(&self.endpoint.lift(), &input);

        EndpointServiceFuture {
            apply,
            input,
            error_handler: self.error_handler,
        }
    }
}

#[allow(missing_docs)]
#[allow(missing_debug_implementations)]
pub struct EndpointServiceFuture<T> {
    apply: ApplyRequest<T>,
    input: Input,
    error_handler: ErrorHandler,
}

impl<T> EndpointServiceFuture<T> {
    fn handle_error(&self, err: &HttpError) -> Response<ResponseBody> {
        (self.error_handler)(err, &self.input)
    }
}

impl<T> futures::Future for EndpointServiceFuture<T>
where
    T: Future,
    T::Output: Responder,
{
    type Item = Response<ResponseBody>;
    type Error = io::Error;

    fn poll(&mut self) -> futures::Poll<Self::Item, Self::Error> {
        let output = match self.apply.poll_ready(&mut self.input) {
            Poll::Pending => return Ok(NotReady),
            Poll::Ready(Some(output)) => output.respond(&self.input),
            Poll::Ready(None) => Err(Error::skipped()),
        };

        let mut response = output.unwrap_or_else(|err| self.handle_error(err.as_http_error()));

        if !response.headers().contains_key(header::SERVER) {
            response.headers_mut().insert(
                header::SERVER,
                HeaderValue::from_static(concat!("finchers-runtime/", env!("CARGO_PKG_VERSION"))),
            );
        }

        Ok(Ready(response))
    }
}

/// A type alias of the error handler used by `EndpointService`.
pub type ErrorHandler = fn(&HttpError, &Input) -> Response<ResponseBody>;

fn default_error_handler(err: &HttpError, _: &Input) -> Response<ResponseBody> {
    let body = err.to_string();
    let body_len = body.len().to_string();

    let mut response = Response::new(ResponseBody::once(body));
    *response.status_mut() = err.status_code();
    response.headers_mut().insert(
        header::CONTENT_TYPE,
        HeaderValue::from_static("text/plain; charset=utf-8"),
    );
    response
        .headers_mut()
        .insert(header::CONTENT_LENGTH, unsafe {
            HeaderValue::from_shared_unchecked(body_len.into())
        });
    err.append_headers(response.headers_mut());

    response
}
