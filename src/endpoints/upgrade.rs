//! **\[unstable\]**
//! Endpoints for supporting HTTP/1.1 protocol upgrade.
//!
//! This module is currently unstable and disabled by default.
//! It is available only when the feature `rt` is set.

#![cfg(feature = "rt")]
#![allow(missing_docs)]

use futures::future;
use futures::IntoFuture;
use http::header::{HeaderName, HeaderValue};
use http::response;
use http::{HttpTryFrom, Response, StatusCode};
use hyper::upgrade::Upgraded;
use tokio::executor::Executor;

use endpoint::{ApplyContext, ApplyResult, Endpoint};
use error::Error;
use output::{Output, OutputContext};
use rt::DefaultExecutor;

/// A builder for constructing an HTTP response
/// with upgrading the protocol.
#[derive(Debug)]
pub struct Builder<Exec = DefaultExecutor> {
    builder: response::Builder,
    exec: Exec,
}

impl Builder<()> {
    pub fn new() -> Builder<DefaultExecutor> {
        Builder::with_executor(DefaultExecutor::current())
    }

    pub fn with_executor<Exec>(exec: Exec) -> Builder<Exec>
    where
        Exec: Executor,
    {
        let mut builder = response::Builder::new();
        builder.status(StatusCode::SWITCHING_PROTOCOLS);

        Builder { builder, exec }
    }
}

impl<Exec> Builder<Exec>
where
    Exec: Executor,
{
    pub fn header<K, V>(mut self, name: K, value: V) -> Self
    where
        HeaderName: HttpTryFrom<K>,
        HeaderValue: HttpTryFrom<V>,
    {
        self.builder.header(name, value);
        self
    }

    pub fn finish<F, R>(self, on_upgrade: F) -> UpgradeOutput<F, Exec>
    where
        F: FnOnce(Upgraded) -> R + Send + 'static,
        R: IntoFuture<Item = (), Error = ()>,
        R::Future: Send + 'static,
    {
        UpgradeOutput {
            builder: self,
            on_upgrade,
        }
    }
}

#[derive(Debug)]
pub struct UpgradeOutput<F, Exec> {
    builder: Builder<Exec>,
    on_upgrade: F,
}

impl<F, R, Exec> Output for UpgradeOutput<F, Exec>
where
    F: FnOnce(Upgraded) -> R + Send + 'static,
    R: IntoFuture<Item = (), Error = ()>,
    R::Future: Send + 'static,
    Exec: Executor,
{
    type Body = ();
    type Error = Error;

    fn respond(self, cx: &mut OutputContext<'_>) -> Result<Response<Self::Body>, Self::Error> {
        let Self {
            builder: Builder {
                mut builder,
                mut exec,
            },
            on_upgrade,
        } = self;
        cx.input()
            .body_mut()
            .upgrade_with_executor(|upgraded| on_upgrade(upgraded), &mut exec);
        builder.body(()).map_err(::error::fail)
    }
}

/// Create an endpoint which just returns a value of `Builder`
/// using the default task executor.
pub fn default() -> Upgrade<impl Fn() -> DefaultExecutor> {
    Upgrade {
        f: || DefaultExecutor::current(),
    }
}

/// Create an endpoint which just returns a value of `Builder`
/// using the default task executor generated by the specified function.
pub fn with_executor<F, Exec>(f: F) -> Upgrade<F>
where
    F: Fn() -> Exec,
    Exec: Executor,
{
    Upgrade { f }
}

#[derive(Debug)]
pub struct Upgrade<F> {
    f: F,
}

impl<'a, F, Exec> Endpoint<'a> for Upgrade<F>
where
    F: Fn() -> Exec + 'a,
    Exec: Executor + 'a,
{
    type Output = (Builder<Exec>,);
    type Future = future::FutureResult<Self::Output, Error>;

    fn apply(&'a self, _: &mut ApplyContext<'_>) -> ApplyResult<Self::Future> {
        Ok(future::ok((Builder::with_executor((self.f)()),)))
    }
}
