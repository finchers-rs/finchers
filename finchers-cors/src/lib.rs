#![feature(rust_2018_preview, futures_api, pin, arbitrary_self_types)]

//! A set of components which provides the support for CORS in Finchers.

#![doc(
    html_root_url = "https://docs.rs/finchers-cors/0.1.0-alpha.1",
    test(attr(feature(rust_2018_preview))),
)]
#![warn(
    missing_docs,
    missing_debug_implementations,
    future_incompatible,
    nonstandard_style,
    rust_2018_idioms,
    unused,
)]
#![cfg_attr(feature = "strict", deny(warnings))]
#![cfg_attr(feature = "strict", doc(test(attr(deny(warnings)))))]

extern crate either;
extern crate failure;
extern crate finchers;
extern crate futures; // 0.3
extern crate http;

use std::collections::HashSet;
use std::pin::PinMut;

use futures::future::{Future, TryFuture};
use futures::task;
use futures::task::Poll;
use futures::try_ready;

use finchers::endpoint::{Context, Endpoint, EndpointResult, Wrapper};
use finchers::error::{Error, HttpError};
use finchers::input::{with_get_cx, Input};
use finchers::output::payload::Optional;
use finchers::output::{Output, OutputContext};

use either::Either;
use failure::Fail;
use http::header;
use http::header::{HeaderMap, HeaderValue};
use http::{Method, Response, StatusCode};

/// A `Wrapper` for building an endpoint with CORS.
#[derive(Debug)]
pub struct CorsFilter {
    hosts: Option<HashSet<String>>,
}

impl CorsFilter {
    /// Creates a `CorsFilter` which allows all origins to access the resource.
    pub fn allow_any() -> CorsFilter {
        CorsFilter { hosts: None }
    }

    /// Creates a `CorsFilter` which allows the specified origins to access the resource.
    pub fn from_whiltelist<T: Into<String>>(hosts: impl IntoIterator<Item = T>) -> CorsFilter {
        CorsFilter {
            hosts: Some(hosts.into_iter().map(Into::into).collect()),
        }
    }
}

impl<'a, E: Endpoint<'a>> Wrapper<'a, E> for CorsFilter {
    type Output = (CorsResponse<E::Output>,);
    type Endpoint = CorsEndpoint<E>;

    fn wrap(self, endpoint: E) -> Self::Endpoint {
        CorsEndpoint {
            endpoint,
            hosts: self.hosts,
        }
    }
}

/// An endpoint which represents a route with CORS handling.
///
/// The value of this type is generated by `CorsFilter::wrap()`.
#[derive(Debug)]
pub struct CorsEndpoint<E> {
    endpoint: E,
    hosts: Option<HashSet<String>>,
}

// FIXME: validate the value of `Access-Control-Request-Method` and `Access-Control-Request-Headers`.

impl<E> CorsEndpoint<E> {
    fn validate_origin_header<'a>(&'a self, input: &Input) -> Result<AllowedOrigin, CorsError>
    where
        E: Endpoint<'a>,
    {
        let origin = input
            .headers()
            .get(header::ORIGIN)
            .ok_or_else(|| CorsError::MissingOrigin)?;

        match self.hosts {
            Some(ref hosts) => {
                let origin_str = origin.to_str().map_err(|_| CorsError::InvalidOrigin)?;
                if !hosts.contains(origin_str) {
                    return Err(CorsError::DisallowedOrigin);
                }
                Ok(AllowedOrigin::Some(origin.clone()))
            }
            None => Ok(AllowedOrigin::Any),
        }
    }

    fn handle_preflight_request<'a>(
        &'a self,
        input: &Input,
    ) -> Result<Either<PreflightResponse, AllowedOrigin>, CorsError>
    where
        E: Endpoint<'a>,
    {
        let origin = self.validate_origin_header(input)?;
        match *input.method() {
            Method::OPTIONS => match input
                .headers()
                .get(header::ACCESS_CONTROL_REQUEST_METHOD)
                .cloned()
            {
                Some(allow_method) => {
                    let allow_headers = input
                        .headers()
                        .get(header::ACCESS_CONTROL_REQUEST_HEADERS)
                        .cloned();
                    Ok(Either::Left(PreflightResponse {
                        origin,
                        allow_method,
                        allow_headers,
                    }))
                }
                None => Ok(Either::Right(origin)),
            },
            _ => Ok(Either::Right(origin)),
        }
    }
}

impl<'a, E> Endpoint<'a> for CorsEndpoint<E>
where
    E: Endpoint<'a>,
{
    type Output = (CorsResponse<E::Output>,);
    type Future = CorsFuture<'a, E>;

    fn apply(&'a self, cx: &mut Context<'_>) -> EndpointResult<Self::Future> {
        Ok(CorsFuture {
            future: self.endpoint.apply(cx)?,
            endpoint: self,
        })
    }
}

#[doc(hidden)]
#[derive(Debug)]
pub struct CorsFuture<'a, E: Endpoint<'a>> {
    future: E::Future,
    endpoint: &'a CorsEndpoint<E>,
}

impl<'a, E> Future for CorsFuture<'a, E>
where
    E: Endpoint<'a>,
{
    type Output = Result<(CorsResponse<E::Output>,), Error>;

    fn poll(self: PinMut<'_, Self>, cx: &mut task::Context<'_>) -> Poll<Self::Output> {
        let this = unsafe { PinMut::get_mut_unchecked(self) };
        let endpoint = this.endpoint;

        match {
            try_ready!(Poll::Ready(with_get_cx(
                |input| endpoint.handle_preflight_request(&*input)
            )))
        } {
            Either::Left(response) => {
                Poll::Ready(Ok((CorsResponse(CorsResponseKind::Preflight(response)),)))
            }
            Either::Right(origin) => {
                let future = unsafe { PinMut::new_unchecked(&mut this.future) };
                future.try_poll(cx).map(|result| match result {
                    Ok(output) => Ok((CorsResponse(CorsResponseKind::Normal { output, origin }),)),
                    Err(cause) => Err(CorsError::Other { cause, origin }.into()),
                })
            }
        }
    }
}

#[allow(missing_docs)]
#[derive(Debug)]
pub struct CorsResponse<T>(CorsResponseKind<T>);

#[derive(Debug)]
enum CorsResponseKind<T> {
    Preflight(PreflightResponse),
    Normal { output: T, origin: AllowedOrigin },
}

#[derive(Debug)]
struct PreflightResponse {
    origin: AllowedOrigin,
    allow_method: HeaderValue,
    allow_headers: Option<HeaderValue>,
}

impl<T: Output> Output for CorsResponse<T> {
    type Body = Optional<T::Body>;
    type Error = Error;

    fn respond(self, cx: &mut OutputContext<'_>) -> Result<Response<Self::Body>, Self::Error> {
        match self.0 {
            CorsResponseKind::Preflight(PreflightResponse {
                origin,
                allow_method,
                allow_headers,
            }) => {
                let mut response = Response::new(Optional::empty());
                response
                    .headers_mut()
                    .insert(header::ACCESS_CONTROL_REQUEST_METHOD, allow_method);
                if let Some(allow_headers) = allow_headers {
                    response
                        .headers_mut()
                        .insert(header::ACCESS_CONTROL_REQUEST_HEADERS, allow_headers);
                }
                response
                    .headers_mut()
                    .insert(header::ACCESS_CONTROL_ALLOW_ORIGIN, origin.into());
                Ok(response)
            }

            CorsResponseKind::Normal { output, origin } => match output.respond(cx) {
                Ok(mut response) => {
                    response
                        .headers_mut()
                        .entry(header::ACCESS_CONTROL_ALLOW_ORIGIN)
                        .unwrap()
                        .or_insert(origin.into());
                    Ok(response.map(Into::into))
                }
                Err(cause) => Err(CorsError::Other {
                    cause: cause.into(),
                    origin,
                }.into()),
            },
        }
    }
}

#[derive(Debug, Clone)]
enum AllowedOrigin {
    Some(HeaderValue),
    Any,
}

impl Into<HeaderValue> for AllowedOrigin {
    fn into(self) -> HeaderValue {
        match self {
            AllowedOrigin::Some(v) => v,
            AllowedOrigin::Any => HeaderValue::from_static("*"),
        }
    }
}

#[derive(Debug, Fail)]
enum CorsError {
    #[fail(display = "Invalid CORS request: the Origin is missing.")]
    MissingOrigin,

    #[fail(display = "Invalid CORS request: the provided Origin is not a valid value.")]
    InvalidOrigin,

    #[fail(display = "Invalid CORS request: the provided Origin is not allowed.")]
    DisallowedOrigin,

    #[fail(display = "{}", cause)]
    Other { cause: Error, origin: AllowedOrigin },
}

impl HttpError for CorsError {
    fn status_code(&self) -> StatusCode {
        match self {
            CorsError::Other { ref cause, .. } => cause.status_code(),
            _ => StatusCode::BAD_REQUEST,
        }
    }

    fn headers(&self, headers: &mut HeaderMap) {
        if let CorsError::Other { ref origin, .. } = self {
            headers
                .entry(header::ACCESS_CONTROL_ALLOW_ORIGIN)
                .unwrap()
                .or_insert_with(|| origin.clone().into());
        }
    }
}
